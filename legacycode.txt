lgacy code that was made in form of macros in foundryvtt

send to chat function

/-- start --/

main();

async function main() {
console.log({Title:`${messageTitle}`,description:`${messageDescription}`})
  let rollMessage = {
    type: CONST.CHAT_MESSAGE_STYLES.ROLL,
    speaker: ChatMessage.getSpeaker({ actor: actor }),
    content: `
    <div class="rollCard">
        <h1 style="font-weight: 800, border-bottom:0">${messageTitle}</h1>
<div style="border: 3px solid black; background-color: white; text-align:left; padding: 5px">
${messageDescription}
</div>
    </div>
    `
  };
  await ChatMessage.create(rollMessage);
}

/-- end --/

simple roll handler

/ -- start -- /
// Macro for rolling an attack from a weapon in the player sheet.

main();

function attributeLabeler(atribute) {
  switch (atribute) {
    case 'atbCop':
      return 'Corpo';
    case 'atbCod':
      return 'Coordenação';
    case 'atbAgi':
      return 'Agilidade';
    case 'atbMnt':
      return 'Mente';
    case 'atbAtc':
      return 'Atenção';
    case 'atbCar':
      return 'Carisma';
    case 'atbVigor':
      return 'Vigor';
    case 'atbReflexos':
      return 'Reflexos';
    case 'atbDeterminacao':
      return 'Determinação';
  }
}

async function main() {
  const actorStats = entity.system.props;
  const rollLabel = scope.rollLabel ? scope.rollLabel : '';

  let rollModifiers = [];

  if (scope.attribute) {
    rollModifiers.push({
      name: attributeLabeler(attribute),
      type: 'Atributo',
      value: parseInt(actorStats[`${attribute}`]),
      checked: true,
    });
  }

  if (scope.pra) {
    rollModifiers.push({
      name: 'Penalidade Por Repetir Ações',
      type: 'Sem Tipo',
      value: -parseInt(actorStats.penalidadeRepetirAcoes),
      checked: true,
    });
  }

  rollModifiers.push({
    name: 'Bônus de Rank',
    type: 'Sem Tipo',
    value: parseInt(actorStats.bonusDeRank),
    checked: scope.trained === 'true' ? true : false,
  });

if(scope.customMod){
rollModifiers = [{name:rollLabel,type:'Sem Tipo',value:parseInt(scope.customMod),checked:true}];
}

  rollModifiers.push({
    name: 'Surto de Reiki',
    type: 'Estado',
    value: scope.strike ? actorStats.bonusDeRank : actorStats.bonusDeRank / 2,
    checked: false,
  });



  function renderTable() {
    let rollModifierTable = `
        <tr style="text-align: left">
        <th>Modificador</th>
        <th>Tipo</th>
        <th>Valor</th>
        <th>Incluir</th>
        </tr>
        `;
    rollModifiers.forEach((modifier, index) => {
      rollModifierTable += `
            <tr>
            <td>${modifier.name}</td>
            <td>${modifier.type}</td>
            <td>${modifier.value >= 0 ? '+' : ''}${modifier.value}</td>
            <td><input type="checkbox" ${
              modifier.checked ? 'checked' : ''
            } id='modifier-${index}' data-key='${index}'/></td>
            </tr>`;
    });
    return rollModifierTable;
  }

  function updateDialogContent(html) {
    html.find('#modifier-table').html(renderTable());
    for (let index = 0; index < rollModifiers.length; index++) {
      html.find(`#modifier-${index}`).click(() => {
        var modifierChecked = html.find(`#modifier-${index}`).is(':checked');
        rollModifiers[index].checked = modifierChecked;
        console.log(rollModifiers);
        updateDialogContent(html);
      });
    }
    updateRollButtonLabel(html);
  }

  function updateRollButtonLabel(html) {
    let rollFinalModifier = rollModifiers.reduce(
      (acc, modifier) =>
        acc + (modifier.checked ? parseInt(modifier.value) : 0),
      0
    );
    html
      .find('.dialog-button.attack')
      .html(`Rolar (${rollFinalModifier >= 0 ? '+' : ''}${rollFinalModifier})`);
  }

  const attackInput = `
    <div styles="display:flex">
        <table id="modifier-table">
        ${renderTable()}
        </table>
        <hr>
        <div style="display:flex; gap: 3px; align-items: center; margin-top: 10px;">
            <input type="text" id="modifier-name" placeholder="Modificador" />
            <input type="number" id="modifier-value" style="width: 60px; text-align: center;" placeholder="1" />
            <select id="modifier-type">
                <option value="Atributo">Atributo</option>
                <option value="Estado">Estado</option>
                <option value="Habilidade">Habilidade</option>
                <option value="Situacional">Situacional</option>
                <option value="Sem Tipo">Sem Tipo</option>
            </select>
            <button id="addButton" style="background-color: #c0a080; border: 1px solid #888;">+Adicionar</button>
        </div>
    </div>
    `;

  let rollFinalModifier = rollModifiers.reduce(
    (acc, modifier) => acc + (modifier.checked ? parseInt(modifier.value) : 0),
    0
  );

  new Dialog({
    title: `Rolando ${rollLabel}`,
    content: attackInput,
    buttons: {
      attack: {
        label: `Rolar (${
          rollFinalModifier >= 0 ? '+' : ''
        }${rollFinalModifier})`,
        callback: async html => {
          let rollFinalModifier = rollModifiers.reduce(
            (acc, modifier) =>
              acc + (modifier.checked ? parseInt(modifier.value) : 0),
            0
          );
          const rollString = `1d20 + ${rollFinalModifier}`;
          let roll = await new Roll(rollString).roll();
console.log(roll)
          let rollMessage = {
            type: CONST.CHAT_MESSAGE_STYLES.ROLL,
            speaker: ChatMessage.getSpeaker({ actor: actor }),
            rolls: [roll],
            content: `
            <div class="rollCard">
              <p class="rollLabel">${rollLabel}</p>
              <h2 class="rollResult">${roll.total}</h2>
            </div>
            `,
          };

          await ChatMessage.applyRollMode(rollMessage, 'roll');
          await ChatMessage.create(rollMessage);

          Hooks.once('renderChatMessage', (chatItem, html) => {
            let reikiModifier = rollModifiers.find(
              mod => mod.name === 'Surto de Reiki'
            );
            if (reikiModifier && reikiModifier.checked) {
              (async () => {
                const docId = 'qoisd0Q6On01Qb4p';
                const compendiumKey = 'csb-remasters.scripts';
                const document = await game.packs
                  .get(compendiumKey)
                  .getDocument(docId);
                await document.execute({
                  actorStats: actorStats,
                });
              })();
            }
          });
        },
      },
    },
    render: html => {
      html.find('#addButton').click(() => {
        const modifierName = html.find('#modifier-name').val();
        const modifierValue = parseInt(html.find('#modifier-value').val());
        const modifierType = html.find('#modifier-type').val();

        if (!modifierName || isNaN(modifierValue)) {
          ui.notifications.error(
            'Por favor, insira um nome de modificador válido e um valor numérico como modificador.'
          );
          return;
        }

        rollModifiers.push({
          name: modifierName,
          type: modifierType,
          value: modifierValue,
          checked: true,
        });

        updateDialogContent(html);
      });

      for (let index = 0; index < rollModifiers.length; index++) {
        html.find(`#modifier-${index}`).click(() => {
          var modifierChecked = html.find(`#modifier-${index}`).is(':checked');
          rollModifiers[index].checked = modifierChecked;
          updateDialogContent(html);
        });
      }
    },
  }).render(true);
}

/-- end --/

reikiSurge

/ -- start --/
main();

async function main() {
   let actor;

  // Attempt to use the actor associated with the user
  if (game.user.character) {
    actor = game.user.character;
  }
  // Fallback: Use the actor of the selected token if exactly one token is selected
  else if (canvas.tokens.controlled.length === 1) {
    actor = canvas.tokens.controlled[0].actor;
  }
  // If no valid actor is found, display an error and exit
  else {
    ui.notifications.error('Por favor, selecione um token ou associe um ator ao seu usuário.');
    return;
  }
  const rollString = `1d6`;
  let roll = await new Roll(rollString).roll();
  console.log(roll);
  let rollMessage = {
    type: CONST.CHAT_MESSAGE_STYLES.ROLL,
    speaker: ChatMessage.getSpeaker({ actor: actor }),
    rolls: [roll],
    content: `
    <div class="rollCard">
        <p class="rollLabel">Checagem de Reiki</p>
        <h2 class="rollResult" style="${roll.total < 3 ? 'color:red' : 'color:green'};">${roll.total}</h2>
        <p class="rollDescription" 
        style="${roll.total < 3 ? 'color:red' : 'color:green'};"
        >
        ${actor.name}, realizou uma checagem de Reiki ${roll.total < 3 ? 'e perdeu uma carga de Reiki': 'e não perdeu uma carga de reiki'}
        </p>
    </div>
    `
  };

  await ChatMessage.applyRollMode(rollMessage, 'roll');
  await ChatMessage.create(rollMessage);
let currentReikiCarga = actor.system.props.reikiCargaAtual || 0;
if (roll.total < 3) {
    // Decrease 'reikiCargaAtual' by one, ensuring it doesn't go below zero
    let newReikiCarga = Math.max(currentReikiCarga - 1, 0);
    await actor.update({ 'system.props.reikiCargaAtual': newReikiCarga });
}
}

/--end--/

weaponAttackHandler

/ -- start -- /

// Macro for rolling an attack from a weapon in the player sheet.

main();

function attributeLabeler(atribute) {
  switch (atribute) {
    case 'atbCop':
      return 'Corpo';
    case 'atbCod':
      return 'Coordenação';
    case 'atbAgi':
      return 'Agilidade';
    case 'atbMnt':
      return 'Mente';
    case 'atbAtc':
      return 'Atenção';
    case 'atbCar':
      return 'Carisma';
  }
}

async function main() {
  const actorStats = entity.system.props;
  const weaponStats = linkedEntity.system.props;

  let rollModifiers = [
    {
      name: attributeLabeler(weaponStats.strikeAttribute),
      type: 'Atributo',
      value: parseInt(actorStats[`${weaponStats.strikeAttribute}`]),
      checked: true,
    },
    {
      name: 'Bônus de Rank',
      type: 'Sem Tipo',
      value: parseInt(actorStats.bonusDeRank),
      checked: true,
    },
  ];

  if (scope.strike) {
    rollModifiers.push({
      name: 'Surto de Reiki',
      type: 'Estado',
      value: Math.floor(actorStats.bonusDeRank),
      checked: false,
    });
  } else {
    rollFinalModifier.push({
      name: 'Surto de Reiki',
      type: 'Estado',
      value: Math.floor(actorStats.bonusDeRank / 2),
      checked: false,
    });
  }

if(weaponStats.useCustomAttackModifier){
rollModifiers = [
    {
      name: 'Modificador de Ataque',
      type: 'Sem Tipo',
      value: parseInt(`${weaponStats.strikeCustomModifier}`),
      checked: true,
    }]
}
  if (scope.pra) {
    rollModifiers.push({
      name: 'Penalidade Por Repetir Ações',
      type: 'Sem Tipo',
      value: -parseInt(actorStats.penalidadeRepetirAcoes),
      checked: true,
    });
  }

  function renderTable() {
    let rollModifierTable = `
        <tr style="text-align: left">
        <th>Modificador</th>
        <th>Tipo</th>
        <th>Valor</th>
        <th>Incluir</th>
        </tr>
        `;
    rollModifiers.forEach((modifier, index) => {
      rollModifierTable += `
            <tr>
            <td>${modifier.name}</td>
            <td>${modifier.type}</td>
            <td>${modifier.value >= 0 ? '+' : ''}${modifier.value}</td>
            <td><input type="checkbox" ${
              modifier.checked ? 'checked' : ''
            } id='modifier-${index}' data-key='${index}'/></td>
            </tr>`;
    });
    return rollModifierTable;
  }

  function updateDialogContent(html) {
    html.find('#modifier-table').html(renderTable());
    for (let index = 0; index < rollModifiers.length; index++) {
      html.find(`#modifier-${index}`).click(() => {
        var modifierChecked = html.find(`#modifier-${index}`).is(':checked');
        rollModifiers[index].checked = modifierChecked;
        console.log(rollModifiers);
        updateDialogContent(html);
      });
    }
    updateRollButtonLabel(html);
  }

  function updateRollButtonLabel(html) {
    let rollFinalModifier = rollModifiers.reduce(
      (acc, modifier) =>
        acc + (modifier.checked ? parseInt(modifier.value) : 0),
      0
    );
    html
      .find('.dialog-button.attack')
      .html(`Rolar (${rollFinalModifier >= 0 ? '+' : ''}${rollFinalModifier})`);
  }

  const attackInput = `
    <div styles="display:flex">
        <table id="modifier-table">
        ${renderTable()}
        </table>
        <hr>
        <div style="display:flex; gap: 3px; align-items: center; margin-top: 10px;">
            <input type="text" id="modifier-name" placeholder="Modificador" />
            <input type="number" id="modifier-value" style="width: 60px; text-align: center;" placeholder="1" />
            <select id="modifier-type">
                <option value="Atributo">Atributo</option>
                <option value="Estado">Estado</option>
                <option value="Habilidade">Habilidade</option>
                <option value="Situacional">Situacional</option>
                <option value="Sem Tipo">Sem Tipo</option>
            </select>
            <button id="addButton" style="background-color: #c0a080; border: 1px solid #888;">+Adicionar</button>
        </div>
    </div>
    `;

  let rollFinalModifier = rollModifiers.reduce(
    (acc, modifier) => acc + (modifier.checked ? parseInt(modifier.value) : 0),
    0
  );

  new Dialog({
    title: 'Rolando ataque',
    content: attackInput,
    buttons: {
      attack: {
        label: `Rolar (${
          rollFinalModifier >= 0 ? '+' : ''
        }${rollFinalModifier})`,
        callback: async html => {
          let rollFinalModifier = rollModifiers.reduce(
            (acc, modifier) =>
              acc + (modifier.checked ? parseInt(modifier.value) : 0),
            0
          );
          const rollString = `1d20 + ${rollFinalModifier}`;
          let roll = await new Roll(rollString).roll();
          let rollMessage = {
            type: CONST.CHAT_MESSAGE_STYLES.ROLL,
            speaker: ChatMessage.getSpeaker({ actor: actor }),
            rolls: [roll],
          };

          let buttons = {
            content:
              '<div style="display:flex"><button id="createDamage">Dano</button><button id="createCriticalDamage">Dano Crítico</button>',
            speaker: ChatMessage.getSpeaker({ actor: actor }),
          };

          await ChatMessage.applyRollMode(rollMessage, 'roll');
          await ChatMessage.create(rollMessage);
          await ChatMessage.create(buttons);

          Hooks.once('renderChatMessage', (chatItem, html) => {
            let reikiModifier = rollModifiers.find(
              mod => mod.name === 'Surto de Reiki'
            );
            if (reikiModifier && reikiModifier.checked) {
              (async () => {
                const docId = 'qoisd0Q6On01Qb4p';
                const compendiumKey = 'csb-remasters.scripts';
                const document = await game.packs
                  .get(compendiumKey)
                  .getDocument(docId);
                await document.execute({
                  actorStats: actorStats,
                  weaponStats: weaponStats,
                });
              })();
            }

            html.find('#createDamage').click(async () => {
              const docId = 'ITr30wD36JeinrX7';
              const compendiumKey = 'csb-remasters.scripts';
              const document = await game.packs
                .get(compendiumKey)
                .getDocument(docId);
              await document.execute({
                actorStats: actorStats,
                weaponStats: weaponStats,
              });
            });
            html.find('#createCriticalDamage').click(async () => {
              const docId = 'ITr30wD36JeinrX7';
              const compendiumKey = 'csb-remasters.scripts';
              const document = await game.packs
                .get(compendiumKey)
                .getDocument(docId);
              await document.execute({
                actorStats: actorStats,
                weaponStats: weaponStats,
                crit: true,
              });
            });
          });
        },
      },
    },
    render: html => {
      html.find('#addButton').click(() => {
        const modifierName = html.find('#modifier-name').val();
        const modifierValue = parseInt(html.find('#modifier-value').val());
        const modifierType = html.find('#modifier-type').val();

        if (!modifierName || isNaN(modifierValue)) {
          ui.notifications.error(
            'Por favor, insira um nome de modificador válido e um valor numérico como modificador.'
          );
          return;
        }

        rollModifiers.push({
          name: modifierName,
          type: modifierType,
          value: modifierValue,
          checked: true,
        });

        updateDialogContent(html);
      });

      for (let index = 0; index < rollModifiers.length; index++) {
        html.find(`#modifier-${index}`).click(() => {
          var modifierChecked = html.find(`#modifier-${index}`).is(':checked');
          rollModifiers[index].checked = modifierChecked;
          updateDialogContent(html);
        });
      }
    },
  }).render(true);
}

/-- end -- /


weaponDamageHandler

/ -- start --/

main();
async function main() {
  // Variável para controle do estado do botão "Resistir" (absorver)
  let soakActive = false;

  // Monta a string do roll de dano
  let additionalDamage =
    weaponStats.additionalDamage !== 0 && weaponStats.additionalDamage != null
      ? ` + ${weaponStats.additionalDamage}[${weaponStats.additionalDamageType}]`
      : '';

  // Verifica se baseDamageAttribute é válido
  let baseDamage = weaponStats.baseDamageAttribute != "-"
    ? ` + ${actorStats[weaponStats.baseDamageAttribute]}`
    : '';
console.log(weaponStats.baseDamageAttribute,baseDamage)
  let damageRollString = `(${weaponStats.baseDamageDieQuantity}d${
    weaponStats.baseDamageDieSize
  }${baseDamage})[${weaponStats.baseDamageType}]${additionalDamage}`;

  if (scope.crit) {
    damageRollString = `2*(${damageRollString})`;
  }
  let roll = await new Roll(damageRollString).roll();

  // Cria a mensagem do roll e os botões
  let rollMessage = {
    type: CONST.CHAT_MESSAGE_TYPES.ROLL,
    speaker: ChatMessage.getSpeaker({ actor: actor }),
    rolls: [roll],
  };

  let buttons = {
    content: `<div style="display:flex; gap: 5px">
                <button id="dealDamage">Normal</button>
                <button id="dealDoubleDamage">Dobro</button>
                <button id="dealHalfDamage">Metade</button>
                <button id="toggleSoak">Resistir</button>
              </div>`,
    speaker: ChatMessage.getSpeaker({ actor: actor }),
  };

  await ChatMessage.applyRollMode(rollMessage, 'roll');
  await ChatMessage.create(rollMessage);
  await ChatMessage.create(buttons);

  // Hook para adicionar os eventos aos botões após renderização da mensagem
  Hooks.once('renderChatMessage', (chatItem, html) => {
    // Botões de dano com multiplicadores
    html.find('#dealDamage').click(() => dealDamage(roll.total, 1));
    html.find('#dealDoubleDamage').click(() => dealDamage(roll.total, 2));
    html.find('#dealHalfDamage').click(() => dealDamage(roll.total, 0.5));

    // Botão de "Resistir" com toggle de estado
    html.find('#toggleSoak').click(() => {
      soakActive = !soakActive;
      // Atualiza o estilo para refletir o estado ativo/inativo
      if (soakActive) {
        html.find('#toggleSoak').css('background-color', 'black');
        html.find('#toggleSoak').css('color', 'white');
      } else {
        html.find('#toggleSoak').css('background-color', '');
        html.find('#toggleSoak').css('color', 'black');
      }
    });
  });

  // Função separada para aplicação do dano
  async function dealDamage(damage, multiplier) {
    let selectedTokens = canvas.tokens.controlled;
    if (selectedTokens.length !== 1) {
      ui.notifications.error('Por favor, selecione apenas um token');
      return;
    }

    let token = selectedTokens[0];
    let actorData = token.actor.system.props;
    // Cálculo do dano base
    let totalDamage = damage * multiplier;

    // Se "Resistir" estiver ativo, reduz o dano final em bonusDeRank
    if (soakActive) {
      totalDamage -= actorData['bonusDeRank'] * 2 || 0;
      if (totalDamage < 0) totalDamage = 0;
    }

    // Atualiza os pontos de vida
    let newHealth = actorData['hpAtual'] - totalDamage;
    if (newHealth < 0) newHealth = 0;

    await token.actor.update({ 'system.props.hpAtual': newHealth });

    // Envia mensagem de dano
    let damageMessage = {
      content: soakActive
        ? `${actorData.name} absorveu ${
            actorData['bonusDeRank'] * 2
          } de dano, recebendo ${totalDamage} de dano.`
        : `${actorData.name} recebeu ${totalDamage} de dano.`,
      speaker: ChatMessage.getSpeaker({ actor: actor }),
    };
    ChatMessage.create(damageMessage);
  }
}

/ -- end --/